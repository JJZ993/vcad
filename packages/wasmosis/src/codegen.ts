/**
 * TypeScript code generation for split WASM modules.
 */

import type { SplitConfig } from './types.js';

/**
 * Options for code generation.
 */
export interface CodegenOptions {
  /** Base path for WASM imports */
  wasmBasePath?: string;

  /** Whether to generate ESM or CJS */
  moduleFormat?: 'esm' | 'cjs';

  /** Custom module init code (per module name) */
  customInit?: Record<string, string>;
}

/**
 * Generate TypeScript registry code from split configuration.
 */
export function generateRegistry(
  config: SplitConfig,
  options: CodegenOptions = {}
): string {
  const { wasmBasePath = './', moduleFormat = 'esm' } = options;

  const imports =
    moduleFormat === 'esm'
      ? `import { createRegistry, defineModule } from 'wasmosis';`
      : `const { createRegistry, defineModule } = require('wasmosis');`;

  const moduleNames = ['core', ...config.secondary.keys()];

  const moduleDefinitions = moduleNames
    .map((name) => generateModuleDefinition(name, config, wasmBasePath, options))
    .join('\n\n');

  const registryExport =
    moduleFormat === 'esm'
      ? `export const registry = createRegistry({ ${moduleNames.join(', ')} });`
      : `exports.registry = createRegistry({ ${moduleNames.join(', ')} });`;

  const moduleExports =
    moduleFormat === 'esm'
      ? moduleNames.map((name) => `export { ${name} };`).join('\n')
      : moduleNames.map((name) => `exports.${name} = ${name};`).join('\n');

  return `/**
 * Auto-generated by wasmosis
 * Do not edit manually
 */

${imports}

${moduleDefinitions}

${registryExport}

${moduleExports}
`;
}

/**
 * Generate a single module definition.
 */
function generateModuleDefinition(
  name: string,
  config: SplitConfig,
  basePath: string,
  options: CodegenOptions
): string {
  const wasmPath = `${basePath}${name}.wasm`;
  const isCore = name === 'core';

  const moduleConfig = isCore ? config.core : config.secondary.get(name);
  if (!moduleConfig) {
    throw new Error(`Unknown module: ${name}`);
  }

  const depends: string[] = isCore ? [] : ('depends' in moduleConfig ? (moduleConfig as { depends: string[] }).depends : []);
  const dependsStr = depends.length > 0 ? `depends: [${depends.map((d: string) => `'${d}'`).join(', ')}],` : '';

  const customInit = options.customInit?.[name];
  const initStr = customInit
    ? `init: async (instance, shared) => {
    ${customInit}
    return instance.exports;
  },`
    : '';

  return `export const ${name} = defineModule({
  name: '${name}',
  loader: () => fetch('${wasmPath}').then(r => r.arrayBuffer()),
  ${dependsStr}
  ${initStr}
});`;
}

/**
 * Generate TypeScript type definitions for split modules.
 */
export function generateTypes(
  config: SplitConfig,
  _functionSignatures?: Record<string, string>
): string {
  const moduleNames = ['core', ...config.secondary.keys()];

  const moduleTypes = moduleNames
    .map((name) => {
      const isCore = name === 'core';
      const moduleConfig = isCore ? config.core : config.secondary.get(name);
      if (!moduleConfig) return '';

      const functions = moduleConfig.functions;
      const functionTypes = functions
        .map((fn) => `  ${fn}: (...args: unknown[]) => unknown;`)
        .join('\n');

      return `export interface ${capitalize(name)}Exports extends WasmExports {
${functionTypes}
}`;
    })
    .join('\n\n');

  return `/**
 * Auto-generated type definitions by wasmosis
 * Do not edit manually
 */

import type { WasmExports, WasmModule, Registry } from 'wasmosis';

${moduleTypes}

export interface WasmosisRegistry extends Registry {
  load<T extends WasmExports = WasmExports>(name: string): Promise<WasmModule<T>>;
  load(name: 'core'): Promise<WasmModule<CoreExports>>;
${[...config.secondary.keys()]
  .map((name) => `  load(name: '${name}'): Promise<WasmModule<${capitalize(name)}Exports>>;`)
  .join('\n')}
}
`;
}

/**
 * Generate a complete module bundle (registry + types).
 */
export function generateBundle(
  config: SplitConfig,
  options: CodegenOptions = {}
): { registry: string; types: string } {
  return {
    registry: generateRegistry(config, options),
    types: generateTypes(config),
  };
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

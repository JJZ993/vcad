//! STEP file writer: converts BRepSolid to STEP format.

use std::collections::HashMap;
use std::io::Write;
use std::path::Path;

use crate::entities::{
    cylinder_to_placement, plane_to_placement, sphere_to_placement, torus_to_placement,
    write_advanced_face, write_axis2_placement_3d, write_cartesian_point, write_closed_shell,
    write_conical_surface, write_cylindrical_surface, write_direction, write_edge_curve,
    write_edge_loop, write_face_bound, write_manifold_solid_brep, write_oriented_edge,
    write_plane, write_spherical_surface, write_toroidal_surface, write_vertex_point,
    AxisPlacement,
};
use crate::error::StepError;

use vcad_kernel_geom::{ConeSurface, CylinderSurface, Plane, SphereSurface, SurfaceKind, TorusSurface};
use vcad_kernel_math::{Dir3, Vec3};
use vcad_kernel_primitives::BRepSolid;
use vcad_kernel_topo::{EdgeId, FaceId, HalfEdgeId, LoopId, Orientation, VertexId};

/// Write a BRepSolid to a STEP file.
///
/// # Arguments
///
/// * `solid` - The B-rep solid to write
/// * `path` - Output file path
pub fn write_step(solid: &BRepSolid, path: impl AsRef<Path>) -> Result<(), StepError> {
    let buffer = write_step_to_buffer(solid)?;
    std::fs::write(path, buffer)?;
    Ok(())
}

/// Write a BRepSolid to a STEP format byte buffer.
///
/// # Arguments
///
/// * `solid` - The B-rep solid to write
///
/// # Returns
///
/// The STEP file contents as bytes.
pub fn write_step_to_buffer(solid: &BRepSolid) -> Result<Vec<u8>, StepError> {
    let mut writer = StepWriter::new(solid);
    writer.write()
}

/// Context for writing STEP files.
struct StepWriter<'a> {
    solid: &'a BRepSolid,
    next_id: u64,
    output: Vec<String>,
    /// Maps vcad VertexId to STEP point ID.
    point_map: HashMap<VertexId, u64>,
    /// Maps vcad VertexId to STEP vertex ID.
    vertex_map: HashMap<VertexId, u64>,
    /// Maps vcad EdgeId to STEP edge ID.
    edge_map: HashMap<EdgeId, u64>,
    /// Maps vcad HalfEdgeId to STEP oriented edge ID.
    oriented_edge_map: HashMap<HalfEdgeId, u64>,
    /// Maps vcad surface index to STEP surface ID.
    surface_map: HashMap<usize, u64>,
    /// Maps vcad LoopId to STEP edge loop ID.
    loop_map: HashMap<LoopId, u64>,
    /// Maps vcad FaceId to STEP face bound ID.
    face_bound_map: HashMap<FaceId, u64>,
    /// Maps vcad FaceId to STEP face ID.
    face_map: HashMap<FaceId, u64>,
}

impl<'a> StepWriter<'a> {
    fn new(solid: &'a BRepSolid) -> Self {
        Self {
            solid,
            next_id: 1,
            output: Vec::new(),
            point_map: HashMap::new(),
            vertex_map: HashMap::new(),
            edge_map: HashMap::new(),
            oriented_edge_map: HashMap::new(),
            surface_map: HashMap::new(),
            loop_map: HashMap::new(),
            face_bound_map: HashMap::new(),
            face_map: HashMap::new(),
        }
    }

    fn alloc_id(&mut self) -> u64 {
        let id = self.next_id;
        self.next_id += 1;
        id
    }

    fn emit(&mut self, id: u64, entity: &str) {
        self.output.push(format!("#{} = {};", id, entity));
    }

    fn write(&mut self) -> Result<Vec<u8>, StepError> {
        // Write all geometry and topology
        self.write_points()?;
        self.write_surfaces()?;
        self.write_vertices()?;
        self.write_edges()?;
        self.write_loops()?;
        self.write_faces()?;
        let shell_id = self.write_shell()?;
        let _solid_id = self.write_solid(shell_id)?;

        // Assemble full file
        let mut buffer = Vec::new();

        // Header
        writeln!(buffer, "ISO-10303-21;")?;
        writeln!(buffer, "HEADER;")?;
        writeln!(
            buffer,
            "FILE_DESCRIPTION(('STEP file generated by vcad'), '2;1');"
        )?;
        writeln!(
            buffer,
            "FILE_NAME('model.step', '{}', ('vcad'), ('vcad'), 'vcad-kernel-step', 'vcad', '');",
            chrono_lite_date()
        )?;
        writeln!(buffer, "FILE_SCHEMA(('AUTOMOTIVE_DESIGN'));")?;
        writeln!(buffer, "ENDSEC;")?;
        writeln!(buffer, "DATA;")?;

        // Entities
        for line in &self.output {
            writeln!(buffer, "{}", line)?;
        }

        // Footer
        writeln!(buffer, "ENDSEC;")?;
        writeln!(buffer, "END-ISO-10303-21;")?;

        Ok(buffer)
    }

    fn write_points(&mut self) -> Result<(), StepError> {
        let topo = &self.solid.topology;
        for (vid, vertex) in &topo.vertices {
            let id = self.alloc_id();
            let entity = write_cartesian_point(&vertex.point, "");
            self.emit(id, &entity);
            self.point_map.insert(vid, id);
        }
        Ok(())
    }

    fn write_vertices(&mut self) -> Result<(), StepError> {
        for (vid, _) in &self.solid.topology.vertices {
            let point_id = self.point_map[&vid];
            let id = self.alloc_id();
            let entity = write_vertex_point("", point_id);
            self.emit(id, &entity);
            self.vertex_map.insert(vid, id);
        }
        Ok(())
    }

    fn write_surfaces(&mut self) -> Result<(), StepError> {
        let geom = &self.solid.geometry;

        for (idx, surface) in geom.surfaces.iter().enumerate() {
            let surf_id = self.alloc_id();

            // Handle each surface type, extracting placement and entity in one pass
            let (placement, entity) = match surface.surface_type() {
                SurfaceKind::Plane => {
                    let plane = surface.as_any().downcast_ref::<Plane>().ok_or_else(|| {
                        StepError::InvalidGeometry("failed to downcast Plane surface".into())
                    })?;
                    let placement_id = self.write_axis_placement(&plane_to_placement(plane))?;
                    (placement_id, write_plane("", placement_id))
                }
                SurfaceKind::Cylinder => {
                    let cyl = surface
                        .as_any()
                        .downcast_ref::<CylinderSurface>()
                        .ok_or_else(|| {
                            StepError::InvalidGeometry("failed to downcast Cylinder surface".into())
                        })?;
                    let placement_id = self.write_axis_placement(&cylinder_to_placement(cyl))?;
                    (
                        placement_id,
                        write_cylindrical_surface(cyl.radius, "", placement_id),
                    )
                }
                SurfaceKind::Sphere => {
                    let sphere = surface
                        .as_any()
                        .downcast_ref::<SphereSurface>()
                        .ok_or_else(|| {
                            StepError::InvalidGeometry("failed to downcast Sphere surface".into())
                        })?;
                    let placement_id = self.write_axis_placement(&sphere_to_placement(sphere))?;
                    (
                        placement_id,
                        write_spherical_surface(sphere.radius, "", placement_id),
                    )
                }
                SurfaceKind::Cone => {
                    let cone = surface.as_any().downcast_ref::<ConeSurface>().ok_or_else(|| {
                        StepError::InvalidGeometry("failed to downcast Cone surface".into())
                    })?;
                    let placement = AxisPlacement {
                        location: cone.apex,
                        axis: Some(cone.axis),
                        ref_direction: Some(cone.ref_dir),
                    };
                    let placement_id = self.write_axis_placement(&placement)?;
                    // For STEP, we need the radius at the reference position
                    // Since apex is at the placement location, radius is 0 there
                    (
                        placement_id,
                        write_conical_surface(0.0, cone.half_angle, "", placement_id),
                    )
                }
                SurfaceKind::Torus => {
                    let torus = surface
                        .as_any()
                        .downcast_ref::<TorusSurface>()
                        .ok_or_else(|| {
                            StepError::InvalidGeometry("failed to downcast Torus surface".into())
                        })?;
                    let placement_id = self.write_axis_placement(&torus_to_placement(torus))?;
                    (
                        placement_id,
                        write_toroidal_surface(torus.major_radius, torus.minor_radius, "", placement_id),
                    )
                }
                _ => {
                    // Unsupported surface type - write as plane placeholder
                    let placement = AxisPlacement {
                        location: vcad_kernel_math::Point3::origin(),
                        axis: None,
                        ref_direction: None,
                    };
                    let placement_id = self.write_axis_placement(&placement)?;
                    (placement_id, write_plane("", placement_id))
                }
            };

            let _ = placement; // placement_id already used in entity construction
            self.emit(surf_id, &entity);
            self.surface_map.insert(idx, surf_id);
        }

        Ok(())
    }

    fn write_axis_placement(&mut self, placement: &AxisPlacement) -> Result<u64, StepError> {
        // Write location point
        let loc_id = self.alloc_id();
        self.emit(loc_id, &write_cartesian_point(&placement.location, ""));

        // Write axis direction if present
        let axis_id = if let Some(axis) = placement.axis {
            let id = self.alloc_id();
            self.emit(id, &write_direction(&axis, ""));
            Some(id)
        } else {
            None
        };

        // Write ref direction if present
        let ref_id = if let Some(ref_dir) = placement.ref_direction {
            let id = self.alloc_id();
            self.emit(id, &write_direction(&ref_dir, ""));
            Some(id)
        } else {
            None
        };

        // Write placement
        let placement_id = self.alloc_id();
        let entity = write_axis2_placement_3d(placement, "", loc_id, axis_id, ref_id);
        self.emit(placement_id, &entity);

        Ok(placement_id)
    }

    fn write_edges(&mut self) -> Result<(), StepError> {
        let topo = &self.solid.topology;

        for (edge_id, edge) in &topo.edges {
            // Get the half-edge to determine vertices
            let he = &topo.half_edges[edge.half_edge];
            let start_vid = he.origin;
            let end_vid = topo.half_edge_dest(edge.half_edge);

            let start_vertex = self.vertex_map[&start_vid];
            let end_vertex = self.vertex_map[&end_vid];

            // Write line geometry for the edge
            let start_point = topo.vertices[start_vid].point;
            let end_point = topo.vertices[end_vid].point;

            let dir_vec = end_point - start_point;
            let magnitude = dir_vec.norm();
            let dir = if magnitude > 1e-15 {
                Dir3::new_normalize(dir_vec)
            } else {
                Dir3::new_normalize(Vec3::x())
            };

            // Write point for line origin
            let line_point_id = self.alloc_id();
            self.emit(line_point_id, &write_cartesian_point(&start_point, ""));

            // Write direction
            let dir_id = self.alloc_id();
            self.emit(dir_id, &write_direction(&dir, ""));

            // Write vector
            let vec_id = self.alloc_id();
            self.emit(
                vec_id,
                &format!("VECTOR('', #{}, {:.15E})", dir_id, magnitude),
            );

            // Write line
            let line_id = self.alloc_id();
            self.emit(
                line_id,
                &format!("LINE('', #{}, #{})", line_point_id, vec_id),
            );

            // Write edge curve
            let step_edge_id = self.alloc_id();
            let entity = write_edge_curve("", start_vertex, end_vertex, line_id, true);
            self.emit(step_edge_id, &entity);
            self.edge_map.insert(edge_id, step_edge_id);
        }

        Ok(())
    }

    fn write_loops(&mut self) -> Result<(), StepError> {
        let topo = &self.solid.topology;

        for (loop_id, _loop) in &topo.loops {
            // Collect oriented edges for this loop
            let mut oriented_edge_ids = Vec::new();

            for he_id in topo.loop_half_edges(loop_id) {
                let he = &topo.half_edges[he_id];
                let edge_id = he.edge.ok_or_else(|| {
                    StepError::InvalidTopology("half-edge has no parent edge".into())
                })?;

                let step_edge_id = self.edge_map[&edge_id];

                // Determine orientation: check if this half-edge is the "primary" one
                let edge = &topo.edges[edge_id];
                let orientation = edge.half_edge == he_id;

                // Write oriented edge
                let oe_id = self.alloc_id();
                let entity = write_oriented_edge("", step_edge_id, orientation);
                self.emit(oe_id, &entity);
                self.oriented_edge_map.insert(he_id, oe_id);

                oriented_edge_ids.push(oe_id);
            }

            // Write edge loop
            let el_id = self.alloc_id();
            let entity = write_edge_loop("", &oriented_edge_ids);
            self.emit(el_id, &entity);
            self.loop_map.insert(loop_id, el_id);
        }

        Ok(())
    }

    fn write_faces(&mut self) -> Result<(), StepError> {
        let topo = &self.solid.topology;

        for (face_id, face) in &topo.faces {
            let surface_id = self.surface_map[&face.surface_index];

            // Write outer bound
            let outer_loop_id = self.loop_map[&face.outer_loop];
            let outer_bound_id = self.alloc_id();
            let entity = write_face_bound("", outer_loop_id, true, true);
            self.emit(outer_bound_id, &entity);

            let mut bound_ids = vec![outer_bound_id];

            // Write inner bounds (holes)
            for inner_loop in &face.inner_loops {
                let inner_loop_id = self.loop_map[inner_loop];
                let inner_bound_id = self.alloc_id();
                let entity = write_face_bound("", inner_loop_id, true, false);
                self.emit(inner_bound_id, &entity);
                bound_ids.push(inner_bound_id);
            }

            self.face_bound_map.insert(face_id, outer_bound_id);

            // Write face
            let same_sense = face.orientation == Orientation::Forward;
            let step_face_id = self.alloc_id();
            let entity = write_advanced_face("", &bound_ids, surface_id, same_sense);
            self.emit(step_face_id, &entity);
            self.face_map.insert(face_id, step_face_id);
        }

        Ok(())
    }

    fn write_shell(&mut self) -> Result<u64, StepError> {
        let topo = &self.solid.topology;
        let solid = &topo.solids[self.solid.solid_id];
        let shell = &topo.shells[solid.outer_shell];

        let face_ids: Vec<u64> = shell.faces.iter().map(|fid| self.face_map[fid]).collect();

        let shell_id = self.alloc_id();
        let entity = write_closed_shell("", &face_ids);
        self.emit(shell_id, &entity);

        Ok(shell_id)
    }

    fn write_solid(&mut self, shell_id: u64) -> Result<u64, StepError> {
        let solid_id = self.alloc_id();
        let entity = write_manifold_solid_brep("Solid", shell_id);
        self.emit(solid_id, &entity);
        Ok(solid_id)
    }
}

/// Simple date string without external chrono dependency.
fn chrono_lite_date() -> String {
    // Just return a placeholder - real implementation would use system time
    "2024-01-01T00:00:00".to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::reader::read_step_from_buffer;
    use vcad_kernel_primitives::make_cube;

    #[test]
    fn test_write_cube() {
        let cube = make_cube(10.0, 10.0, 10.0);
        let buffer = write_step_to_buffer(&cube).unwrap();
        let content = String::from_utf8_lossy(&buffer);

        // Check essential content
        assert!(content.contains("ISO-10303-21"));
        assert!(content.contains("MANIFOLD_SOLID_BREP"));
        assert!(content.contains("CLOSED_SHELL"));
        assert!(content.contains("ADVANCED_FACE"));
        assert!(content.contains("PLANE"));
        assert!(content.contains("CARTESIAN_POINT"));
    }

    #[test]
    fn test_roundtrip_cube() {
        // Create a cube
        let original = make_cube(10.0, 20.0, 30.0);

        // Write to STEP
        let buffer = write_step_to_buffer(&original).unwrap();

        // Read back
        let solids = read_step_from_buffer(&buffer).unwrap();
        assert_eq!(solids.len(), 1);

        let imported = &solids[0];

        // Verify topology matches
        assert_eq!(
            original.topology.vertices.len(),
            imported.topology.vertices.len()
        );
        assert_eq!(original.topology.faces.len(), imported.topology.faces.len());
        assert_eq!(original.topology.edges.len(), imported.topology.edges.len());

        // Verify geometry matches
        assert_eq!(
            original.geometry.surfaces.len(),
            imported.geometry.surfaces.len()
        );
    }
}

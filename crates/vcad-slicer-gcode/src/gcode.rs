//! G-code generation from slice results.

use std::fmt::Write;

use vcad_slicer::{Polygon, Polyline, PrintLayer, SliceResult};

use crate::printer::PrinterProfile;

/// G-code generation settings.
#[derive(Debug, Clone)]
pub struct GcodeSettings {
    /// Printer profile.
    pub printer: PrinterProfile,
    /// Print temperature (°C).
    pub print_temp: u32,
    /// Bed temperature (°C).
    pub bed_temp: u32,
    /// Print speed for infill (mm/s).
    pub print_speed: f64,
    /// Print speed for outer perimeters (mm/s).
    pub outer_wall_speed: f64,
    /// Print speed for inner perimeters (mm/s).
    pub inner_wall_speed: f64,
    /// Travel speed (mm/s).
    pub travel_speed: f64,
    /// First layer speed multiplier (0.0-1.0).
    pub first_layer_speed_factor: f64,
    /// Enable cooling fan.
    pub fan_enabled: bool,
    /// Fan speed (0-255).
    pub fan_speed: u8,
    /// Layer at which to enable fan.
    pub fan_start_layer: usize,
}

impl Default for GcodeSettings {
    fn default() -> Self {
        Self {
            printer: PrinterProfile::default(),
            print_temp: 210,
            bed_temp: 60,
            print_speed: 60.0,
            outer_wall_speed: 40.0,
            inner_wall_speed: 50.0,
            travel_speed: 150.0,
            first_layer_speed_factor: 0.5,
            fan_enabled: true,
            fan_speed: 255,
            fan_start_layer: 2,
        }
    }
}

/// G-code generator.
pub struct GcodeGenerator {
    settings: GcodeSettings,
    output: String,
    current_x: f64,
    current_y: f64,
    current_z: f64,
    current_e: f64,
    current_f: f64,
    is_retracted: bool,
}

impl GcodeGenerator {
    /// Create a new G-code generator.
    pub fn new(settings: GcodeSettings) -> Self {
        Self {
            settings,
            output: String::with_capacity(1024 * 1024), // 1MB initial capacity
            current_x: 0.0,
            current_y: 0.0,
            current_z: 0.0,
            current_e: 0.0,
            current_f: 0.0,
            is_retracted: false,
        }
    }

    /// Generate G-code from slice result.
    pub fn generate(&mut self, result: &SliceResult) -> String {
        self.output.clear();

        // Header
        self.write_header();

        // Start G-code
        self.write_start_gcode();

        // Process layers
        for layer in &result.layers {
            self.process_layer(layer);
        }

        // End G-code
        self.write_end_gcode();

        self.output.clone()
    }

    fn write_header(&mut self) {
        let _ = writeln!(self.output, "; Generated by vcad-slicer");
        let _ = writeln!(self.output, "; Printer: {}", self.settings.printer.name);
        let _ = writeln!(
            self.output,
            "; Nozzle: {:.2}mm",
            self.settings.printer.nozzle_diameter
        );
        let _ = writeln!(
            self.output,
            "; Print temp: {}C, Bed temp: {}C",
            self.settings.print_temp, self.settings.bed_temp
        );
        let _ = writeln!(self.output);
    }

    fn write_start_gcode(&mut self) {
        let start = self
            .settings
            .printer
            .flavor
            .start_gcode()
            .replace("{print_temp}", &self.settings.print_temp.to_string())
            .replace("{bed_temp}", &self.settings.bed_temp.to_string());

        self.output.push_str(&start);
        let _ = writeln!(self.output);
    }

    fn write_end_gcode(&mut self) {
        let end = self.settings.printer.flavor.end_gcode();
        self.output.push_str(end);
    }

    fn process_layer(&mut self, layer: &PrintLayer) {
        let is_first = layer.index == 0;
        let speed_factor = if is_first {
            self.settings.first_layer_speed_factor
        } else {
            1.0
        };

        // Layer change
        let _ = writeln!(
            self.output,
            "{}; Layer {}, Z={:.3}",
            self.settings.printer.flavor.layer_change_gcode(),
            layer.index,
            layer.z
        );

        // Move to layer Z
        self.move_z(layer.z);

        // Fan control
        if self.settings.fan_enabled && layer.index == self.settings.fan_start_layer {
            let _ = writeln!(self.output, "M106 S{} ; Fan on", self.settings.fan_speed);
        }

        // Print outer perimeters (slow, visible surface)
        let outer_speed = self.settings.outer_wall_speed * speed_factor;
        for perimeter in &layer.outer_perimeters {
            self.print_polygon(perimeter, outer_speed, layer.layer_height);
        }

        // Print inner perimeters
        let inner_speed = self.settings.inner_wall_speed * speed_factor;
        for perimeter in &layer.inner_perimeters {
            self.print_polygon(perimeter, inner_speed, layer.layer_height);
        }

        // Print infill
        let infill_speed = self.settings.print_speed * speed_factor;
        for path in &layer.infill {
            self.print_polyline(path, infill_speed, layer.layer_height);
        }

        // Print support
        if let Some(support) = &layer.support {
            for region in support {
                self.print_polygon(region, infill_speed, layer.layer_height);
            }
        }
    }

    fn print_polygon(&mut self, polygon: &Polygon, speed: f64, layer_height: f64) {
        if polygon.points.is_empty() {
            return;
        }

        // Travel to start
        let start = &polygon.points[0];
        self.travel_to(start.x, start.y);

        // Unretract
        self.unretract();

        // Print polygon
        let feedrate = speed * 60.0; // mm/s to mm/min
        for point in polygon.points.iter().skip(1) {
            self.extrude_to(point.x, point.y, feedrate, layer_height);
        }

        // Close polygon
        self.extrude_to(start.x, start.y, feedrate, layer_height);

        // Retract
        self.retract();
    }

    fn print_polyline(&mut self, polyline: &Polyline, speed: f64, layer_height: f64) {
        if polyline.points.is_empty() {
            return;
        }

        // Travel to start
        let start = &polyline.points[0];
        self.travel_to(start.x, start.y);

        // Unretract
        self.unretract();

        // Print line
        let feedrate = speed * 60.0;
        for point in polyline.points.iter().skip(1) {
            self.extrude_to(point.x, point.y, feedrate, layer_height);
        }

        // Retract
        self.retract();
    }

    fn move_z(&mut self, z: f64) {
        if (z - self.current_z).abs() > 0.001 {
            let feedrate = self.settings.printer.max_feedrate_z * 60.0;
            let _ = writeln!(self.output, "G1 Z{:.3} F{:.0}", z, feedrate);
            self.current_z = z;
        }
    }

    fn travel_to(&mut self, x: f64, y: f64) {
        if (x - self.current_x).abs() < 0.001 && (y - self.current_y).abs() < 0.001 {
            return;
        }

        // Retract before travel
        self.retract();

        // Z-hop
        let z_hop = self.settings.printer.z_hop;
        if z_hop > 0.0 {
            let _ = writeln!(self.output, "G1 Z{:.3}", self.current_z + z_hop);
        }

        // Travel move
        let feedrate = self.settings.travel_speed * 60.0;
        if (self.current_f - feedrate).abs() > 0.1 {
            let _ = writeln!(self.output, "G1 X{:.3} Y{:.3} F{:.0}", x, y, feedrate);
            self.current_f = feedrate;
        } else {
            let _ = writeln!(self.output, "G1 X{:.3} Y{:.3}", x, y);
        }

        // Z-hop down
        if z_hop > 0.0 {
            let _ = writeln!(self.output, "G1 Z{:.3}", self.current_z);
        }

        self.current_x = x;
        self.current_y = y;
    }

    fn extrude_to(&mut self, x: f64, y: f64, feedrate: f64, layer_height: f64) {
        let dx = x - self.current_x;
        let dy = y - self.current_y;
        let distance = (dx * dx + dy * dy).sqrt();

        if distance < 0.001 {
            return;
        }

        // Calculate extrusion amount
        let line_width = self.settings.printer.nozzle_diameter * 1.1;
        let filament_diameter = self.settings.printer.filament_diameter;
        let filament_area = std::f64::consts::PI * (filament_diameter / 2.0).powi(2);
        let extrusion_area = line_width * layer_height;
        let e_per_mm = extrusion_area / filament_area;

        self.current_e += distance * e_per_mm;

        // G1 move with extrusion
        if (self.current_f - feedrate).abs() > 0.1 {
            let _ = writeln!(
                self.output,
                "G1 X{:.3} Y{:.3} E{:.5} F{:.0}",
                x, y, self.current_e, feedrate
            );
            self.current_f = feedrate;
        } else {
            let _ = writeln!(
                self.output,
                "G1 X{:.3} Y{:.3} E{:.5}",
                x, y, self.current_e
            );
        }

        self.current_x = x;
        self.current_y = y;
    }

    fn retract(&mut self) {
        if self.is_retracted {
            return;
        }

        let retract_dist = self.settings.printer.retraction_distance;
        let retract_speed = self.settings.printer.retraction_speed * 60.0;

        self.current_e -= retract_dist;
        let _ = writeln!(
            self.output,
            "G1 E{:.5} F{:.0} ; retract",
            self.current_e, retract_speed
        );

        self.is_retracted = true;
    }

    fn unretract(&mut self) {
        if !self.is_retracted {
            return;
        }

        let retract_dist = self.settings.printer.retraction_distance;
        let retract_speed = self.settings.printer.retraction_speed * 60.0;

        self.current_e += retract_dist;
        let _ = writeln!(
            self.output,
            "G1 E{:.5} F{:.0} ; unretract",
            self.current_e, retract_speed
        );

        self.is_retracted = false;
    }
}

/// Generate G-code from slice result.
pub fn generate_gcode(result: &SliceResult, settings: GcodeSettings) -> String {
    let mut generator = GcodeGenerator::new(settings);
    generator.generate(result)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gcode_header() {
        let settings = GcodeSettings::default();
        let mut gen = GcodeGenerator::new(settings);
        gen.write_header();
        assert!(gen.output.contains("vcad-slicer"));
    }
}
